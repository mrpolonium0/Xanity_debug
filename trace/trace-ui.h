/* AUTOGENERATED STUB FOR ANDROID BUILD */
#ifndef TRACE_TRACE_UI_H
#define TRACE_TRACE_UI_H

/* No-op trace events */
#ifndef trace_event_get_state_backends
#define trace_event_get_state_backends(id) (0)
#endif
#ifndef trace_event_get_state
#define trace_event_get_state(id) (0)
#endif
#define TRACE_CLIPBOARD_CHECK_SERIAL 0
#define TRACE_CLIPBOARD_CHECK_SERIAL_ENABLED 0
#define TRACE_CLIPBOARD_CHECK_SERIAL_BACKEND_DSTATE() (0)
static inline void trace_clipboard_check_serial(int cur, int recv, bool ok) {
    (void)cur;
    (void)recv;
    (void)ok;
}
#define TRACE_CLIPBOARD_RESET_SERIAL 0
#define TRACE_CLIPBOARD_RESET_SERIAL_ENABLED 0
#define TRACE_CLIPBOARD_RESET_SERIAL_BACKEND_DSTATE() (0)
static inline void trace_clipboard_reset_serial(void) {
}
#define TRACE_CONSOLE_GFX_CLOSE 0
#define TRACE_CONSOLE_GFX_CLOSE_ENABLED 0
#define TRACE_CONSOLE_GFX_CLOSE_BACKEND_DSTATE() (0)
static inline void trace_console_gfx_close(int index) {
    (void)index;
}
#define TRACE_CONSOLE_GFX_NEW 0
#define TRACE_CONSOLE_GFX_NEW_ENABLED 0
#define TRACE_CONSOLE_GFX_NEW_BACKEND_DSTATE() (0)
static inline void trace_console_gfx_new(void) {
}
#define TRACE_CONSOLE_GFX_REUSE 0
#define TRACE_CONSOLE_GFX_REUSE_ENABLED 0
#define TRACE_CONSOLE_GFX_REUSE_BACKEND_DSTATE() (0)
static inline void trace_console_gfx_reuse(int index) {
    (void)index;
}
#define TRACE_CONSOLE_PUTCHAR_CSI 0
#define TRACE_CONSOLE_PUTCHAR_CSI_ENABLED 0
#define TRACE_CONSOLE_PUTCHAR_CSI_BACKEND_DSTATE() (0)
static inline void trace_console_putchar_csi(int esc_param0, int esc_param1, int ch, int nb_esc_params) {
    (void)esc_param0;
    (void)esc_param1;
    (void)ch;
    (void)nb_esc_params;
}
#define TRACE_CONSOLE_PUTCHAR_UNHANDLED 0
#define TRACE_CONSOLE_PUTCHAR_UNHANDLED_ENABLED 0
#define TRACE_CONSOLE_PUTCHAR_UNHANDLED_BACKEND_DSTATE() (0)
static inline void trace_console_putchar_unhandled(int ch) {
    (void)ch;
}
#define TRACE_CONSOLE_REFRESH 0
#define TRACE_CONSOLE_REFRESH_ENABLED 0
#define TRACE_CONSOLE_REFRESH_BACKEND_DSTATE() (0)
static inline void trace_console_refresh(int interval) {
    (void)interval;
}
#define TRACE_CONSOLE_SELECT 0
#define TRACE_CONSOLE_SELECT_ENABLED 0
#define TRACE_CONSOLE_SELECT_BACKEND_DSTATE() (0)
static inline void trace_console_select(int nr) {
    (void)nr;
}
#define TRACE_CONSOLE_TXT_NEW 0
#define TRACE_CONSOLE_TXT_NEW_ENABLED 0
#define TRACE_CONSOLE_TXT_NEW_BACKEND_DSTATE() (0)
static inline void trace_console_txt_new(int w, int h) {
    (void)w;
    (void)h;
}
#define TRACE_DBUS_CAN_SHARE_MAP 0
#define TRACE_DBUS_CAN_SHARE_MAP_ENABLED 0
#define TRACE_DBUS_CAN_SHARE_MAP_BACKEND_DSTATE() (0)
static inline void trace_dbus_can_share_map(bool share) {
    (void)share;
}
#define TRACE_DBUS_CLIPBOARD_GRAB 0
#define TRACE_DBUS_CLIPBOARD_GRAB_ENABLED 0
#define TRACE_DBUS_CLIPBOARD_GRAB_BACKEND_DSTATE() (0)
static inline void trace_dbus_clipboard_grab(int selection, unsigned int serial) {
    (void)selection;
    (void)serial;
}
#define TRACE_DBUS_CLIPBOARD_GRAB_FAILED 0
#define TRACE_DBUS_CLIPBOARD_GRAB_FAILED_ENABLED 0
#define TRACE_DBUS_CLIPBOARD_GRAB_FAILED_BACKEND_DSTATE() (0)
static inline void trace_dbus_clipboard_grab_failed(void) {
}
#define TRACE_DBUS_CLIPBOARD_QEMU_REQUEST 0
#define TRACE_DBUS_CLIPBOARD_QEMU_REQUEST_ENABLED 0
#define TRACE_DBUS_CLIPBOARD_QEMU_REQUEST_BACKEND_DSTATE() (0)
static inline void trace_dbus_clipboard_qemu_request(int type) {
    (void)type;
}
#define TRACE_DBUS_CLIPBOARD_REGISTER 0
#define TRACE_DBUS_CLIPBOARD_REGISTER_ENABLED 0
#define TRACE_DBUS_CLIPBOARD_REGISTER_BACKEND_DSTATE() (0)
static inline void trace_dbus_clipboard_register(const char *bus_name) {
    (void)bus_name;
}
#define TRACE_DBUS_CLIPBOARD_UNREGISTER 0
#define TRACE_DBUS_CLIPBOARD_UNREGISTER_ENABLED 0
#define TRACE_DBUS_CLIPBOARD_UNREGISTER_BACKEND_DSTATE() (0)
static inline void trace_dbus_clipboard_unregister(const char *bus_name) {
    (void)bus_name;
}
#define TRACE_DBUS_FILTER 0
#define TRACE_DBUS_FILTER_ENABLED 0
#define TRACE_DBUS_FILTER_BACKEND_DSTATE() (0)
static inline void trace_dbus_filter(unsigned int serial, unsigned int filter) {
    (void)serial;
    (void)filter;
}
#define TRACE_DBUS_GL_GFX_SWITCH 0
#define TRACE_DBUS_GL_GFX_SWITCH_ENABLED 0
#define TRACE_DBUS_GL_GFX_SWITCH_BACKEND_DSTATE() (0)
static inline void trace_dbus_gl_gfx_switch(void *p) {
    (void)p;
}
#define TRACE_DBUS_KBD_PRESS 0
#define TRACE_DBUS_KBD_PRESS_ENABLED 0
#define TRACE_DBUS_KBD_PRESS_BACKEND_DSTATE() (0)
static inline void trace_dbus_kbd_press(unsigned int keycode) {
    (void)keycode;
}
#define TRACE_DBUS_KBD_RELEASE 0
#define TRACE_DBUS_KBD_RELEASE_ENABLED 0
#define TRACE_DBUS_KBD_RELEASE_BACKEND_DSTATE() (0)
static inline void trace_dbus_kbd_release(unsigned int keycode) {
    (void)keycode;
}
#define TRACE_DBUS_LISTENER_VANISHED 0
#define TRACE_DBUS_LISTENER_VANISHED_ENABLED 0
#define TRACE_DBUS_LISTENER_VANISHED_BACKEND_DSTATE() (0)
static inline void trace_dbus_listener_vanished(const char *bus_name) {
    (void)bus_name;
}
#define TRACE_DBUS_MOUSE_PRESS 0
#define TRACE_DBUS_MOUSE_PRESS_ENABLED 0
#define TRACE_DBUS_MOUSE_PRESS_BACKEND_DSTATE() (0)
static inline void trace_dbus_mouse_press(unsigned int button) {
    (void)button;
}
#define TRACE_DBUS_MOUSE_REL_MOTION 0
#define TRACE_DBUS_MOUSE_REL_MOTION_ENABLED 0
#define TRACE_DBUS_MOUSE_REL_MOTION_BACKEND_DSTATE() (0)
static inline void trace_dbus_mouse_rel_motion(int dx, int dy) {
    (void)dx;
    (void)dy;
}
#define TRACE_DBUS_MOUSE_RELEASE 0
#define TRACE_DBUS_MOUSE_RELEASE_ENABLED 0
#define TRACE_DBUS_MOUSE_RELEASE_BACKEND_DSTATE() (0)
static inline void trace_dbus_mouse_release(unsigned int button) {
    (void)button;
}
#define TRACE_DBUS_MOUSE_SET_POS 0
#define TRACE_DBUS_MOUSE_SET_POS_ENABLED 0
#define TRACE_DBUS_MOUSE_SET_POS_BACKEND_DSTATE() (0)
static inline void trace_dbus_mouse_set_pos(unsigned int x, unsigned int y) {
    (void)x;
    (void)y;
}
#define TRACE_DBUS_REGISTERED_LISTENER 0
#define TRACE_DBUS_REGISTERED_LISTENER_ENABLED 0
#define TRACE_DBUS_REGISTERED_LISTENER_BACKEND_DSTATE() (0)
static inline void trace_dbus_registered_listener(const char *bus_name) {
    (void)bus_name;
}
#define TRACE_DBUS_SCANOUT_TEXTURE 0
#define TRACE_DBUS_SCANOUT_TEXTURE_ENABLED 0
#define TRACE_DBUS_SCANOUT_TEXTURE_BACKEND_DSTATE() (0)
static inline void trace_dbus_scanout_texture(uint32_t tex_id, bool backing_y_0_top, uint32_t backing_width, uint32_t backing_height, uint32_t x, uint32_t y, uint32_t w, uint32_t h) {
    (void)tex_id;
    (void)backing_y_0_top;
    (void)backing_width;
    (void)backing_height;
    (void)x;
    (void)y;
    (void)w;
    (void)h;
}
#define TRACE_DBUS_TOUCH_SEND_EVENT 0
#define TRACE_DBUS_TOUCH_SEND_EVENT_ENABLED 0
#define TRACE_DBUS_TOUCH_SEND_EVENT_BACKEND_DSTATE() (0)
static inline void trace_dbus_touch_send_event(unsigned int kind, uint32_t num_slot, uint32_t x, uint32_t y) {
    (void)kind;
    (void)num_slot;
    (void)x;
    (void)y;
}
#define TRACE_DBUS_UPDATE 0
#define TRACE_DBUS_UPDATE_ENABLED 0
#define TRACE_DBUS_UPDATE_BACKEND_DSTATE() (0)
static inline void trace_dbus_update(int x, int y, int w, int h) {
    (void)x;
    (void)y;
    (void)w;
    (void)h;
}
#define TRACE_DBUS_UPDATE_GL 0
#define TRACE_DBUS_UPDATE_GL_ENABLED 0
#define TRACE_DBUS_UPDATE_GL_BACKEND_DSTATE() (0)
static inline void trace_dbus_update_gl(int x, int y, int w, int h) {
    (void)x;
    (void)y;
    (void)w;
    (void)h;
}
#define TRACE_DISPLAYCHANGELISTENER_REGISTER 0
#define TRACE_DISPLAYCHANGELISTENER_REGISTER_ENABLED 0
#define TRACE_DISPLAYCHANGELISTENER_REGISTER_BACKEND_DSTATE() (0)
static inline void trace_displaychangelistener_register(void *dcl, const char *name) {
    (void)dcl;
    (void)name;
}
#define TRACE_DISPLAYCHANGELISTENER_UNREGISTER 0
#define TRACE_DISPLAYCHANGELISTENER_UNREGISTER_ENABLED 0
#define TRACE_DISPLAYCHANGELISTENER_UNREGISTER_BACKEND_DSTATE() (0)
static inline void trace_displaychangelistener_unregister(void *dcl, const char *name) {
    (void)dcl;
    (void)name;
}
#define TRACE_DISPLAYSURFACE_CREATE 0
#define TRACE_DISPLAYSURFACE_CREATE_ENABLED 0
#define TRACE_DISPLAYSURFACE_CREATE_BACKEND_DSTATE() (0)
static inline void trace_displaysurface_create(int w, int h) {
    (void)w;
    (void)h;
}
#define TRACE_DISPLAYSURFACE_CREATE_FROM 0
#define TRACE_DISPLAYSURFACE_CREATE_FROM_ENABLED 0
#define TRACE_DISPLAYSURFACE_CREATE_FROM_BACKEND_DSTATE() (0)
static inline void trace_displaysurface_create_from(void *display_surface, int w, int h, uint32_t format) {
    (void)display_surface;
    (void)w;
    (void)h;
    (void)format;
}
#define TRACE_DISPLAYSURFACE_CREATE_PIXMAN 0
#define TRACE_DISPLAYSURFACE_CREATE_PIXMAN_ENABLED 0
#define TRACE_DISPLAYSURFACE_CREATE_PIXMAN_BACKEND_DSTATE() (0)
static inline void trace_displaysurface_create_pixman(void *display_surface) {
    (void)display_surface;
}
#define TRACE_DISPLAYSURFACE_FREE 0
#define TRACE_DISPLAYSURFACE_FREE_ENABLED 0
#define TRACE_DISPLAYSURFACE_FREE_BACKEND_DSTATE() (0)
static inline void trace_displaysurface_free(void *display_surface) {
    (void)display_surface;
}
#define TRACE_EGL_INIT_D3D11_DEVICE 0
#define TRACE_EGL_INIT_D3D11_DEVICE_ENABLED 0
#define TRACE_EGL_INIT_D3D11_DEVICE_BACKEND_DSTATE() (0)
static inline void trace_egl_init_d3d11_device(void *p) {
    (void)p;
}
#define TRACE_GD_GL_AREA_CREATE_CONTEXT 0
#define TRACE_GD_GL_AREA_CREATE_CONTEXT_ENABLED 0
#define TRACE_GD_GL_AREA_CREATE_CONTEXT_BACKEND_DSTATE() (0)
static inline void trace_gd_gl_area_create_context(void *ctx, int major, int minor) {
    (void)ctx;
    (void)major;
    (void)minor;
}
#define TRACE_GD_GL_AREA_DESTROY_CONTEXT 0
#define TRACE_GD_GL_AREA_DESTROY_CONTEXT_ENABLED 0
#define TRACE_GD_GL_AREA_DESTROY_CONTEXT_BACKEND_DSTATE() (0)
static inline void trace_gd_gl_area_destroy_context(void *ctx, void *current_ctx) {
    (void)ctx;
    (void)current_ctx;
}
#define TRACE_GD_GRAB 0
#define TRACE_GD_GRAB_ENABLED 0
#define TRACE_GD_GRAB_BACKEND_DSTATE() (0)
static inline void trace_gd_grab(const char *tab, const char *device, const char *reason) {
    (void)tab;
    (void)device;
    (void)reason;
}
#define TRACE_GD_KEY_EVENT 0
#define TRACE_GD_KEY_EVENT_ENABLED 0
#define TRACE_GD_KEY_EVENT_BACKEND_DSTATE() (0)
static inline void trace_gd_key_event(const char *tab, int gdk_keycode, int qkeycode, const char *action) {
    (void)tab;
    (void)gdk_keycode;
    (void)qkeycode;
    (void)action;
}
#define TRACE_GD_KEYMAP_WINDOWING 0
#define TRACE_GD_KEYMAP_WINDOWING_ENABLED 0
#define TRACE_GD_KEYMAP_WINDOWING_BACKEND_DSTATE() (0)
static inline void trace_gd_keymap_windowing(const char *name) {
    (void)name;
}
#define TRACE_GD_MOTION_EVENT 0
#define TRACE_GD_MOTION_EVENT_ENABLED 0
#define TRACE_GD_MOTION_EVENT_BACKEND_DSTATE() (0)
static inline void trace_gd_motion_event(int ww, int wh, int ws, int x, int y) {
    (void)ww;
    (void)wh;
    (void)ws;
    (void)x;
    (void)y;
}
#define TRACE_GD_SWITCH 0
#define TRACE_GD_SWITCH_ENABLED 0
#define TRACE_GD_SWITCH_BACKEND_DSTATE() (0)
static inline void trace_gd_switch(const char *tab, int width, int height) {
    (void)tab;
    (void)width;
    (void)height;
}
#define TRACE_GD_UNGRAB 0
#define TRACE_GD_UNGRAB_ENABLED 0
#define TRACE_GD_UNGRAB_BACKEND_DSTATE() (0)
static inline void trace_gd_ungrab(const char *tab, const char *device) {
    (void)tab;
    (void)device;
}
#define TRACE_GD_UPDATE 0
#define TRACE_GD_UPDATE_ENABLED 0
#define TRACE_GD_UPDATE_BACKEND_DSTATE() (0)
static inline void trace_gd_update(const char *tab, int x, int y, int w, int h) {
    (void)tab;
    (void)x;
    (void)y;
    (void)w;
    (void)h;
}
#define TRACE_INPUT_EVENT_ABS 0
#define TRACE_INPUT_EVENT_ABS_ENABLED 0
#define TRACE_INPUT_EVENT_ABS_BACKEND_DSTATE() (0)
static inline void trace_input_event_abs(int conidx, const char *axis, int value) {
    (void)conidx;
    (void)axis;
    (void)value;
}
#define TRACE_INPUT_EVENT_BTN 0
#define TRACE_INPUT_EVENT_BTN_ENABLED 0
#define TRACE_INPUT_EVENT_BTN_BACKEND_DSTATE() (0)
static inline void trace_input_event_btn(int conidx, const char *btn, bool down) {
    (void)conidx;
    (void)btn;
    (void)down;
}
#define TRACE_INPUT_EVENT_KEY_NUMBER 0
#define TRACE_INPUT_EVENT_KEY_NUMBER_ENABLED 0
#define TRACE_INPUT_EVENT_KEY_NUMBER_BACKEND_DSTATE() (0)
static inline void trace_input_event_key_number(int conidx, int number, const char *qcode, bool down) {
    (void)conidx;
    (void)number;
    (void)qcode;
    (void)down;
}
#define TRACE_INPUT_EVENT_KEY_QCODE 0
#define TRACE_INPUT_EVENT_KEY_QCODE_ENABLED 0
#define TRACE_INPUT_EVENT_KEY_QCODE_BACKEND_DSTATE() (0)
static inline void trace_input_event_key_qcode(int conidx, const char *qcode, bool down) {
    (void)conidx;
    (void)qcode;
    (void)down;
}
#define TRACE_INPUT_EVENT_MTT 0
#define TRACE_INPUT_EVENT_MTT_ENABLED 0
#define TRACE_INPUT_EVENT_MTT_BACKEND_DSTATE() (0)
static inline void trace_input_event_mtt(int conidx, const char *axis, int value) {
    (void)conidx;
    (void)axis;
    (void)value;
}
#define TRACE_INPUT_EVENT_REL 0
#define TRACE_INPUT_EVENT_REL_ENABLED 0
#define TRACE_INPUT_EVENT_REL_BACKEND_DSTATE() (0)
static inline void trace_input_event_rel(int conidx, const char *axis, int value) {
    (void)conidx;
    (void)axis;
    (void)value;
}
#define TRACE_INPUT_EVENT_SYNC 0
#define TRACE_INPUT_EVENT_SYNC_ENABLED 0
#define TRACE_INPUT_EVENT_SYNC_BACKEND_DSTATE() (0)
static inline void trace_input_event_sync(void) {
}
#define TRACE_KEYMAP_ADD 0
#define TRACE_KEYMAP_ADD_ENABLED 0
#define TRACE_KEYMAP_ADD_BACKEND_DSTATE() (0)
static inline void trace_keymap_add(int sym, int code, const char *line) {
    (void)sym;
    (void)code;
    (void)line;
}
#define TRACE_KEYMAP_PARSE 0
#define TRACE_KEYMAP_PARSE_ENABLED 0
#define TRACE_KEYMAP_PARSE_BACKEND_DSTATE() (0)
static inline void trace_keymap_parse(const char *file) {
    (void)file;
}
#define TRACE_KEYMAP_UNMAPPED 0
#define TRACE_KEYMAP_UNMAPPED_ENABLED 0
#define TRACE_KEYMAP_UNMAPPED_BACKEND_DSTATE() (0)
static inline void trace_keymap_unmapped(int sym) {
    (void)sym;
}
#define TRACE_PPM_SAVE 0
#define TRACE_PPM_SAVE_ENABLED 0
#define TRACE_PPM_SAVE_BACKEND_DSTATE() (0)
static inline void trace_ppm_save(int fd, void *image) {
    (void)fd;
    (void)image;
}
#define TRACE_QEMU_SPICE_ADD_MEMSLOT 0
#define TRACE_QEMU_SPICE_ADD_MEMSLOT_ENABLED 0
#define TRACE_QEMU_SPICE_ADD_MEMSLOT_BACKEND_DSTATE() (0)
static inline void trace_qemu_spice_add_memslot(int qid, uint32_t slot_id, unsigned long virt_start, unsigned long virt_end, int async) {
    (void)qid;
    (void)slot_id;
    (void)virt_start;
    (void)virt_end;
    (void)async;
}
#define TRACE_QEMU_SPICE_CREATE_PRIMARY_SURFACE 0
#define TRACE_QEMU_SPICE_CREATE_PRIMARY_SURFACE_ENABLED 0
#define TRACE_QEMU_SPICE_CREATE_PRIMARY_SURFACE_BACKEND_DSTATE() (0)
static inline void trace_qemu_spice_create_primary_surface(int qid, uint32_t sid, void *surface, int async) {
    (void)qid;
    (void)sid;
    (void)surface;
    (void)async;
}
#define TRACE_QEMU_SPICE_CREATE_UPDATE 0
#define TRACE_QEMU_SPICE_CREATE_UPDATE_ENABLED 0
#define TRACE_QEMU_SPICE_CREATE_UPDATE_BACKEND_DSTATE() (0)
static inline void trace_qemu_spice_create_update(uint32_t left, uint32_t right, uint32_t top, uint32_t bottom) {
    (void)left;
    (void)right;
    (void)top;
    (void)bottom;
}
#define TRACE_QEMU_SPICE_DEL_MEMSLOT 0
#define TRACE_QEMU_SPICE_DEL_MEMSLOT_ENABLED 0
#define TRACE_QEMU_SPICE_DEL_MEMSLOT_BACKEND_DSTATE() (0)
static inline void trace_qemu_spice_del_memslot(int qid, uint32_t gid, uint32_t slot_id) {
    (void)qid;
    (void)gid;
    (void)slot_id;
}
#define TRACE_QEMU_SPICE_DESTROY_PRIMARY_SURFACE 0
#define TRACE_QEMU_SPICE_DESTROY_PRIMARY_SURFACE_ENABLED 0
#define TRACE_QEMU_SPICE_DESTROY_PRIMARY_SURFACE_BACKEND_DSTATE() (0)
static inline void trace_qemu_spice_destroy_primary_surface(int qid, uint32_t sid, int async) {
    (void)qid;
    (void)sid;
    (void)async;
}
#define TRACE_QEMU_SPICE_DISPLAY_REFRESH 0
#define TRACE_QEMU_SPICE_DISPLAY_REFRESH_ENABLED 0
#define TRACE_QEMU_SPICE_DISPLAY_REFRESH_BACKEND_DSTATE() (0)
static inline void trace_qemu_spice_display_refresh(int qid, int notify) {
    (void)qid;
    (void)notify;
}
#define TRACE_QEMU_SPICE_DISPLAY_SURFACE 0
#define TRACE_QEMU_SPICE_DISPLAY_SURFACE_ENABLED 0
#define TRACE_QEMU_SPICE_DISPLAY_SURFACE_BACKEND_DSTATE() (0)
static inline void trace_qemu_spice_display_surface(int qid, uint32_t w, uint32_t h, int fast) {
    (void)qid;
    (void)w;
    (void)h;
    (void)fast;
}
#define TRACE_QEMU_SPICE_DISPLAY_UPDATE 0
#define TRACE_QEMU_SPICE_DISPLAY_UPDATE_ENABLED 0
#define TRACE_QEMU_SPICE_DISPLAY_UPDATE_BACKEND_DSTATE() (0)
static inline void trace_qemu_spice_display_update(int qid, uint32_t x, uint32_t y, uint32_t w, uint32_t h) {
    (void)qid;
    (void)x;
    (void)y;
    (void)w;
    (void)h;
}
#define TRACE_QEMU_SPICE_GL_CURSOR 0
#define TRACE_QEMU_SPICE_GL_CURSOR_ENABLED 0
#define TRACE_QEMU_SPICE_GL_CURSOR_BACKEND_DSTATE() (0)
static inline void trace_qemu_spice_gl_cursor(int qid, bool enabled, bool hotspot) {
    (void)qid;
    (void)enabled;
    (void)hotspot;
}
#define TRACE_QEMU_SPICE_GL_FORWARD_DMABUF 0
#define TRACE_QEMU_SPICE_GL_FORWARD_DMABUF_ENABLED 0
#define TRACE_QEMU_SPICE_GL_FORWARD_DMABUF_BACKEND_DSTATE() (0)
static inline void trace_qemu_spice_gl_forward_dmabuf(int qid, uint32_t width, uint32_t height) {
    (void)qid;
    (void)width;
    (void)height;
}
#define TRACE_QEMU_SPICE_GL_RENDER_DMABUF 0
#define TRACE_QEMU_SPICE_GL_RENDER_DMABUF_ENABLED 0
#define TRACE_QEMU_SPICE_GL_RENDER_DMABUF_BACKEND_DSTATE() (0)
static inline void trace_qemu_spice_gl_render_dmabuf(int qid, uint32_t width, uint32_t height) {
    (void)qid;
    (void)width;
    (void)height;
}
#define TRACE_QEMU_SPICE_GL_SCANOUT_DISABLE 0
#define TRACE_QEMU_SPICE_GL_SCANOUT_DISABLE_ENABLED 0
#define TRACE_QEMU_SPICE_GL_SCANOUT_DISABLE_BACKEND_DSTATE() (0)
static inline void trace_qemu_spice_gl_scanout_disable(int qid) {
    (void)qid;
}
#define TRACE_QEMU_SPICE_GL_SCANOUT_TEXTURE 0
#define TRACE_QEMU_SPICE_GL_SCANOUT_TEXTURE_ENABLED 0
#define TRACE_QEMU_SPICE_GL_SCANOUT_TEXTURE_BACKEND_DSTATE() (0)
static inline void trace_qemu_spice_gl_scanout_texture(int qid, uint32_t w, uint32_t h, uint32_t fourcc) {
    (void)qid;
    (void)w;
    (void)h;
    (void)fourcc;
}
#define TRACE_QEMU_SPICE_GL_SURFACE 0
#define TRACE_QEMU_SPICE_GL_SURFACE_ENABLED 0
#define TRACE_QEMU_SPICE_GL_SURFACE_BACKEND_DSTATE() (0)
static inline void trace_qemu_spice_gl_surface(int qid, uint32_t w, uint32_t h, uint32_t fourcc) {
    (void)qid;
    (void)w;
    (void)h;
    (void)fourcc;
}
#define TRACE_QEMU_SPICE_GL_UPDATE 0
#define TRACE_QEMU_SPICE_GL_UPDATE_ENABLED 0
#define TRACE_QEMU_SPICE_GL_UPDATE_BACKEND_DSTATE() (0)
static inline void trace_qemu_spice_gl_update(int qid, uint32_t x, uint32_t y, uint32_t w, uint32_t h) {
    (void)qid;
    (void)x;
    (void)y;
    (void)w;
    (void)h;
}
#define TRACE_QEMU_SPICE_UI_INFO 0
#define TRACE_QEMU_SPICE_UI_INFO_ENABLED 0
#define TRACE_QEMU_SPICE_UI_INFO_BACKEND_DSTATE() (0)
static inline void trace_qemu_spice_ui_info(int qid, uint32_t width, uint32_t height) {
    (void)qid;
    (void)width;
    (void)height;
}
#define TRACE_QEMU_SPICE_WAKEUP 0
#define TRACE_QEMU_SPICE_WAKEUP_ENABLED 0
#define TRACE_QEMU_SPICE_WAKEUP_BACKEND_DSTATE() (0)
static inline void trace_qemu_spice_wakeup(uint32_t qid) {
    (void)qid;
}
#define TRACE_SDL2_PROCESS_KEY 0
#define TRACE_SDL2_PROCESS_KEY_ENABLED 0
#define TRACE_SDL2_PROCESS_KEY_BACKEND_DSTATE() (0)
static inline void trace_sdl2_process_key(int sdl_scancode, int qcode, const char *action) {
    (void)sdl_scancode;
    (void)qcode;
    (void)action;
}
#define TRACE_VDAGENT_CB_GRAB_DISCARD 0
#define TRACE_VDAGENT_CB_GRAB_DISCARD_ENABLED 0
#define TRACE_VDAGENT_CB_GRAB_DISCARD_BACKEND_DSTATE() (0)
static inline void trace_vdagent_cb_grab_discard(const char *name, int cur, int recv) {
    (void)name;
    (void)cur;
    (void)recv;
}
#define TRACE_VDAGENT_CB_GRAB_SELECTION 0
#define TRACE_VDAGENT_CB_GRAB_SELECTION_ENABLED 0
#define TRACE_VDAGENT_CB_GRAB_SELECTION_BACKEND_DSTATE() (0)
static inline void trace_vdagent_cb_grab_selection(const char *name) {
    (void)name;
}
#define TRACE_VDAGENT_CB_GRAB_TYPE 0
#define TRACE_VDAGENT_CB_GRAB_TYPE_ENABLED 0
#define TRACE_VDAGENT_CB_GRAB_TYPE_BACKEND_DSTATE() (0)
static inline void trace_vdagent_cb_grab_type(const char *name) {
    (void)name;
}
#define TRACE_VDAGENT_CB_SERIAL_DISCARD 0
#define TRACE_VDAGENT_CB_SERIAL_DISCARD_ENABLED 0
#define TRACE_VDAGENT_CB_SERIAL_DISCARD_BACKEND_DSTATE() (0)
static inline void trace_vdagent_cb_serial_discard(uint32_t current, uint32_t received) {
    (void)current;
    (void)received;
}
#define TRACE_VDAGENT_CLOSE 0
#define TRACE_VDAGENT_CLOSE_ENABLED 0
#define TRACE_VDAGENT_CLOSE_BACKEND_DSTATE() (0)
static inline void trace_vdagent_close(void) {
}
#define TRACE_VDAGENT_DISCONNECT 0
#define TRACE_VDAGENT_DISCONNECT_ENABLED 0
#define TRACE_VDAGENT_DISCONNECT_BACKEND_DSTATE() (0)
static inline void trace_vdagent_disconnect(void) {
}
#define TRACE_VDAGENT_FE_OPEN 0
#define TRACE_VDAGENT_FE_OPEN_ENABLED 0
#define TRACE_VDAGENT_FE_OPEN_BACKEND_DSTATE() (0)
static inline void trace_vdagent_fe_open(bool fe_open) {
    (void)fe_open;
}
#define TRACE_VDAGENT_PEER_CAP 0
#define TRACE_VDAGENT_PEER_CAP_ENABLED 0
#define TRACE_VDAGENT_PEER_CAP_BACKEND_DSTATE() (0)
static inline void trace_vdagent_peer_cap(const char *name) {
    (void)name;
}
#define TRACE_VDAGENT_RECV_CHUNK 0
#define TRACE_VDAGENT_RECV_CHUNK_ENABLED 0
#define TRACE_VDAGENT_RECV_CHUNK_BACKEND_DSTATE() (0)
static inline void trace_vdagent_recv_chunk(uint32_t size) {
    (void)size;
}
#define TRACE_VDAGENT_RECV_MSG 0
#define TRACE_VDAGENT_RECV_MSG_ENABLED 0
#define TRACE_VDAGENT_RECV_MSG_BACKEND_DSTATE() (0)
static inline void trace_vdagent_recv_msg(const char *name, uint32_t size) {
    (void)name;
    (void)size;
}
#define TRACE_VDAGENT_SEND 0
#define TRACE_VDAGENT_SEND_ENABLED 0
#define TRACE_VDAGENT_SEND_BACKEND_DSTATE() (0)
static inline void trace_vdagent_send(const char *name) {
    (void)name;
}
#define TRACE_VDAGENT_SEND_EMPTY_CLIPBOARD 0
#define TRACE_VDAGENT_SEND_EMPTY_CLIPBOARD_ENABLED 0
#define TRACE_VDAGENT_SEND_EMPTY_CLIPBOARD_BACKEND_DSTATE() (0)
static inline void trace_vdagent_send_empty_clipboard(void) {
}
#define TRACE_VNC_AUTH_FAIL 0
#define TRACE_VNC_AUTH_FAIL_ENABLED 0
#define TRACE_VNC_AUTH_FAIL_BACKEND_DSTATE() (0)
static inline void trace_vnc_auth_fail(void *state, int method, const char *message, const char *reason) {
    (void)state;
    (void)method;
    (void)message;
    (void)reason;
}
#define TRACE_VNC_AUTH_INIT 0
#define TRACE_VNC_AUTH_INIT_ENABLED 0
#define TRACE_VNC_AUTH_INIT_BACKEND_DSTATE() (0)
static inline void trace_vnc_auth_init(void *display, int websock, int auth, int subauth) {
    (void)display;
    (void)websock;
    (void)auth;
    (void)subauth;
}
#define TRACE_VNC_AUTH_PASS 0
#define TRACE_VNC_AUTH_PASS_ENABLED 0
#define TRACE_VNC_AUTH_PASS_BACKEND_DSTATE() (0)
static inline void trace_vnc_auth_pass(void *state, int method) {
    (void)state;
    (void)method;
}
#define TRACE_VNC_AUTH_REJECT 0
#define TRACE_VNC_AUTH_REJECT_ENABLED 0
#define TRACE_VNC_AUTH_REJECT_BACKEND_DSTATE() (0)
static inline void trace_vnc_auth_reject(void *state, int expect, int got) {
    (void)state;
    (void)expect;
    (void)got;
}
#define TRACE_VNC_AUTH_SASL_ACL 0
#define TRACE_VNC_AUTH_SASL_ACL_ENABLED 0
#define TRACE_VNC_AUTH_SASL_ACL_BACKEND_DSTATE() (0)
static inline void trace_vnc_auth_sasl_acl(void *state, int allow) {
    (void)state;
    (void)allow;
}
#define TRACE_VNC_AUTH_SASL_MECH_CHOOSE 0
#define TRACE_VNC_AUTH_SASL_MECH_CHOOSE_ENABLED 0
#define TRACE_VNC_AUTH_SASL_MECH_CHOOSE_BACKEND_DSTATE() (0)
static inline void trace_vnc_auth_sasl_mech_choose(void *state, const char *mech) {
    (void)state;
    (void)mech;
}
#define TRACE_VNC_AUTH_SASL_MECH_LIST 0
#define TRACE_VNC_AUTH_SASL_MECH_LIST_ENABLED 0
#define TRACE_VNC_AUTH_SASL_MECH_LIST_BACKEND_DSTATE() (0)
static inline void trace_vnc_auth_sasl_mech_list(void *state, const char *mechs) {
    (void)state;
    (void)mechs;
}
#define TRACE_VNC_AUTH_SASL_SSF 0
#define TRACE_VNC_AUTH_SASL_SSF_ENABLED 0
#define TRACE_VNC_AUTH_SASL_SSF_BACKEND_DSTATE() (0)
static inline void trace_vnc_auth_sasl_ssf(void *state, int ssf) {
    (void)state;
    (void)ssf;
}
#define TRACE_VNC_AUTH_SASL_START 0
#define TRACE_VNC_AUTH_SASL_START_ENABLED 0
#define TRACE_VNC_AUTH_SASL_START_BACKEND_DSTATE() (0)
static inline void trace_vnc_auth_sasl_start(void *state, const void *clientdata, size_t clientlen, const void *serverdata, size_t severlen, int ret) {
    (void)state;
    (void)clientdata;
    (void)clientlen;
    (void)serverdata;
    (void)severlen;
    (void)ret;
}
#define TRACE_VNC_AUTH_SASL_STEP 0
#define TRACE_VNC_AUTH_SASL_STEP_ENABLED 0
#define TRACE_VNC_AUTH_SASL_STEP_BACKEND_DSTATE() (0)
static inline void trace_vnc_auth_sasl_step(void *state, const void *clientdata, size_t clientlen, const void *serverdata, size_t severlen, int ret) {
    (void)state;
    (void)clientdata;
    (void)clientlen;
    (void)serverdata;
    (void)severlen;
    (void)ret;
}
#define TRACE_VNC_AUTH_SASL_USERNAME 0
#define TRACE_VNC_AUTH_SASL_USERNAME_ENABLED 0
#define TRACE_VNC_AUTH_SASL_USERNAME_BACKEND_DSTATE() (0)
static inline void trace_vnc_auth_sasl_username(void *state, const char *name) {
    (void)state;
    (void)name;
}
#define TRACE_VNC_AUTH_START 0
#define TRACE_VNC_AUTH_START_ENABLED 0
#define TRACE_VNC_AUTH_START_BACKEND_DSTATE() (0)
static inline void trace_vnc_auth_start(void *state, int method) {
    (void)state;
    (void)method;
}
#define TRACE_VNC_AUTH_VENCRYPT_SUBAUTH 0
#define TRACE_VNC_AUTH_VENCRYPT_SUBAUTH_ENABLED 0
#define TRACE_VNC_AUTH_VENCRYPT_SUBAUTH_BACKEND_DSTATE() (0)
static inline void trace_vnc_auth_vencrypt_subauth(void *state, int auth) {
    (void)state;
    (void)auth;
}
#define TRACE_VNC_AUTH_VENCRYPT_VERSION 0
#define TRACE_VNC_AUTH_VENCRYPT_VERSION_ENABLED 0
#define TRACE_VNC_AUTH_VENCRYPT_VERSION_BACKEND_DSTATE() (0)
static inline void trace_vnc_auth_vencrypt_version(void *state, int major, int minor) {
    (void)state;
    (void)major;
    (void)minor;
}
#define TRACE_VNC_CLIENT_CONNECT 0
#define TRACE_VNC_CLIENT_CONNECT_ENABLED 0
#define TRACE_VNC_CLIENT_CONNECT_BACKEND_DSTATE() (0)
static inline void trace_vnc_client_connect(void *state, void *ioc) {
    (void)state;
    (void)ioc;
}
#define TRACE_VNC_CLIENT_DISCONNECT_FINISH 0
#define TRACE_VNC_CLIENT_DISCONNECT_FINISH_ENABLED 0
#define TRACE_VNC_CLIENT_DISCONNECT_FINISH_BACKEND_DSTATE() (0)
static inline void trace_vnc_client_disconnect_finish(void *state, void *ioc) {
    (void)state;
    (void)ioc;
}
#define TRACE_VNC_CLIENT_DISCONNECT_START 0
#define TRACE_VNC_CLIENT_DISCONNECT_START_ENABLED 0
#define TRACE_VNC_CLIENT_DISCONNECT_START_BACKEND_DSTATE() (0)
static inline void trace_vnc_client_disconnect_start(void *state, void *ioc) {
    (void)state;
    (void)ioc;
}
#define TRACE_VNC_CLIENT_EOF 0
#define TRACE_VNC_CLIENT_EOF_ENABLED 0
#define TRACE_VNC_CLIENT_EOF_BACKEND_DSTATE() (0)
static inline void trace_vnc_client_eof(void *state, void *ioc) {
    (void)state;
    (void)ioc;
}
#define TRACE_VNC_CLIENT_IO_ERROR 0
#define TRACE_VNC_CLIENT_IO_ERROR_ENABLED 0
#define TRACE_VNC_CLIENT_IO_ERROR_BACKEND_DSTATE() (0)
static inline void trace_vnc_client_io_error(void *state, void *ioc, const char *msg) {
    (void)state;
    (void)ioc;
    (void)msg;
}
#define TRACE_VNC_CLIENT_IO_WRAP 0
#define TRACE_VNC_CLIENT_IO_WRAP_ENABLED 0
#define TRACE_VNC_CLIENT_IO_WRAP_BACKEND_DSTATE() (0)
static inline void trace_vnc_client_io_wrap(void *state, void *ioc, const char *type) {
    (void)state;
    (void)ioc;
    (void)type;
}
#define TRACE_VNC_CLIENT_OUTPUT_LIMIT 0
#define TRACE_VNC_CLIENT_OUTPUT_LIMIT_ENABLED 0
#define TRACE_VNC_CLIENT_OUTPUT_LIMIT_BACKEND_DSTATE() (0)
static inline void trace_vnc_client_output_limit(void *state, void *ioc, size_t offset, size_t threshold) {
    (void)state;
    (void)ioc;
    (void)offset;
    (void)threshold;
}
#define TRACE_VNC_CLIENT_PIXEL_FORMAT 0
#define TRACE_VNC_CLIENT_PIXEL_FORMAT_ENABLED 0
#define TRACE_VNC_CLIENT_PIXEL_FORMAT_BACKEND_DSTATE() (0)
static inline void trace_vnc_client_pixel_format(void *state, void *ioc, int bpp, int depth, int endian) {
    (void)state;
    (void)ioc;
    (void)bpp;
    (void)depth;
    (void)endian;
}
#define TRACE_VNC_CLIENT_PIXEL_FORMAT_BLUE 0
#define TRACE_VNC_CLIENT_PIXEL_FORMAT_BLUE_ENABLED 0
#define TRACE_VNC_CLIENT_PIXEL_FORMAT_BLUE_BACKEND_DSTATE() (0)
static inline void trace_vnc_client_pixel_format_blue(void *state, void *ioc, int max, int bits, int shift, int mask) {
    (void)state;
    (void)ioc;
    (void)max;
    (void)bits;
    (void)shift;
    (void)mask;
}
#define TRACE_VNC_CLIENT_PIXEL_FORMAT_GREEN 0
#define TRACE_VNC_CLIENT_PIXEL_FORMAT_GREEN_ENABLED 0
#define TRACE_VNC_CLIENT_PIXEL_FORMAT_GREEN_BACKEND_DSTATE() (0)
static inline void trace_vnc_client_pixel_format_green(void *state, void *ioc, int max, int bits, int shift, int mask) {
    (void)state;
    (void)ioc;
    (void)max;
    (void)bits;
    (void)shift;
    (void)mask;
}
#define TRACE_VNC_CLIENT_PIXEL_FORMAT_RED 0
#define TRACE_VNC_CLIENT_PIXEL_FORMAT_RED_ENABLED 0
#define TRACE_VNC_CLIENT_PIXEL_FORMAT_RED_BACKEND_DSTATE() (0)
static inline void trace_vnc_client_pixel_format_red(void *state, void *ioc, int max, int bits, int shift, int mask) {
    (void)state;
    (void)ioc;
    (void)max;
    (void)bits;
    (void)shift;
    (void)mask;
}
#define TRACE_VNC_CLIENT_THROTTLE_AUDIO 0
#define TRACE_VNC_CLIENT_THROTTLE_AUDIO_ENABLED 0
#define TRACE_VNC_CLIENT_THROTTLE_AUDIO_BACKEND_DSTATE() (0)
static inline void trace_vnc_client_throttle_audio(void *state, void *ioc, size_t offset) {
    (void)state;
    (void)ioc;
    (void)offset;
}
#define TRACE_VNC_CLIENT_THROTTLE_FORCED 0
#define TRACE_VNC_CLIENT_THROTTLE_FORCED_ENABLED 0
#define TRACE_VNC_CLIENT_THROTTLE_FORCED_BACKEND_DSTATE() (0)
static inline void trace_vnc_client_throttle_forced(void *state, void *ioc, int job_update, size_t offset) {
    (void)state;
    (void)ioc;
    (void)job_update;
    (void)offset;
}
#define TRACE_VNC_CLIENT_THROTTLE_INCREMENTAL 0
#define TRACE_VNC_CLIENT_THROTTLE_INCREMENTAL_ENABLED 0
#define TRACE_VNC_CLIENT_THROTTLE_INCREMENTAL_BACKEND_DSTATE() (0)
static inline void trace_vnc_client_throttle_incremental(void *state, void *ioc, int job_update, size_t offset) {
    (void)state;
    (void)ioc;
    (void)job_update;
    (void)offset;
}
#define TRACE_VNC_CLIENT_THROTTLE_THRESHOLD 0
#define TRACE_VNC_CLIENT_THROTTLE_THRESHOLD_ENABLED 0
#define TRACE_VNC_CLIENT_THROTTLE_THRESHOLD_BACKEND_DSTATE() (0)
static inline void trace_vnc_client_throttle_threshold(void *state, void *ioc, size_t oldoffset, size_t offset, int client_width, int client_height, int bytes_per_pixel, void *audio_cap) {
    (void)state;
    (void)ioc;
    (void)oldoffset;
    (void)offset;
    (void)client_width;
    (void)client_height;
    (void)bytes_per_pixel;
    (void)audio_cap;
}
#define TRACE_VNC_CLIENT_UNTHROTTLE_FORCED 0
#define TRACE_VNC_CLIENT_UNTHROTTLE_FORCED_ENABLED 0
#define TRACE_VNC_CLIENT_UNTHROTTLE_FORCED_BACKEND_DSTATE() (0)
static inline void trace_vnc_client_unthrottle_forced(void *state, void *ioc) {
    (void)state;
    (void)ioc;
}
#define TRACE_VNC_CLIENT_UNTHROTTLE_INCREMENTAL 0
#define TRACE_VNC_CLIENT_UNTHROTTLE_INCREMENTAL_ENABLED 0
#define TRACE_VNC_CLIENT_UNTHROTTLE_INCREMENTAL_BACKEND_DSTATE() (0)
static inline void trace_vnc_client_unthrottle_incremental(void *state, void *ioc, size_t offset) {
    (void)state;
    (void)ioc;
    (void)offset;
}
#define TRACE_VNC_JOB_ADD_RECT 0
#define TRACE_VNC_JOB_ADD_RECT_ENABLED 0
#define TRACE_VNC_JOB_ADD_RECT_BACKEND_DSTATE() (0)
static inline void trace_vnc_job_add_rect(void *state, void *job, int x, int y, int w, int h) {
    (void)state;
    (void)job;
    (void)x;
    (void)y;
    (void)w;
    (void)h;
}
#define TRACE_VNC_JOB_CLAMP_RECT 0
#define TRACE_VNC_JOB_CLAMP_RECT_ENABLED 0
#define TRACE_VNC_JOB_CLAMP_RECT_BACKEND_DSTATE() (0)
static inline void trace_vnc_job_clamp_rect(void *state, void *job, int x, int y, int w, int h) {
    (void)state;
    (void)job;
    (void)x;
    (void)y;
    (void)w;
    (void)h;
}
#define TRACE_VNC_JOB_CLAMPED_RECT 0
#define TRACE_VNC_JOB_CLAMPED_RECT_ENABLED 0
#define TRACE_VNC_JOB_CLAMPED_RECT_BACKEND_DSTATE() (0)
static inline void trace_vnc_job_clamped_rect(void *state, void *job, int x, int y, int w, int h) {
    (void)state;
    (void)job;
    (void)x;
    (void)y;
    (void)w;
    (void)h;
}
#define TRACE_VNC_JOB_DISCARD_RECT 0
#define TRACE_VNC_JOB_DISCARD_RECT_ENABLED 0
#define TRACE_VNC_JOB_DISCARD_RECT_BACKEND_DSTATE() (0)
static inline void trace_vnc_job_discard_rect(void *state, void *job, int x, int y, int w, int h) {
    (void)state;
    (void)job;
    (void)x;
    (void)y;
    (void)w;
    (void)h;
}
#define TRACE_VNC_JOB_NRECTS 0
#define TRACE_VNC_JOB_NRECTS_ENABLED 0
#define TRACE_VNC_JOB_NRECTS_BACKEND_DSTATE() (0)
static inline void trace_vnc_job_nrects(void *state, void *job, int nrects) {
    (void)state;
    (void)job;
    (void)nrects;
}
#define TRACE_VNC_KEY_EVENT_EXT 0
#define TRACE_VNC_KEY_EVENT_EXT_ENABLED 0
#define TRACE_VNC_KEY_EVENT_EXT_BACKEND_DSTATE() (0)
static inline void trace_vnc_key_event_ext(bool down, int sym, int keycode, const char *name) {
    (void)down;
    (void)sym;
    (void)keycode;
    (void)name;
}
#define TRACE_VNC_KEY_EVENT_MAP 0
#define TRACE_VNC_KEY_EVENT_MAP_ENABLED 0
#define TRACE_VNC_KEY_EVENT_MAP_BACKEND_DSTATE() (0)
static inline void trace_vnc_key_event_map(bool down, int sym, int keycode, const char *name) {
    (void)down;
    (void)sym;
    (void)keycode;
    (void)name;
}
#define TRACE_VNC_KEY_GUEST_LEDS 0
#define TRACE_VNC_KEY_GUEST_LEDS_ENABLED 0
#define TRACE_VNC_KEY_GUEST_LEDS_BACKEND_DSTATE() (0)
static inline void trace_vnc_key_guest_leds(bool caps, bool num, bool scroll) {
    (void)caps;
    (void)num;
    (void)scroll;
}
#define TRACE_VNC_KEY_MAP_INIT 0
#define TRACE_VNC_KEY_MAP_INIT_ENABLED 0
#define TRACE_VNC_KEY_MAP_INIT_BACKEND_DSTATE() (0)
static inline void trace_vnc_key_map_init(const char *layout) {
    (void)layout;
}
#define TRACE_VNC_KEY_SYNC_CAPSLOCK 0
#define TRACE_VNC_KEY_SYNC_CAPSLOCK_ENABLED 0
#define TRACE_VNC_KEY_SYNC_CAPSLOCK_BACKEND_DSTATE() (0)
static inline void trace_vnc_key_sync_capslock(bool on) {
    (void)on;
}
#define TRACE_VNC_KEY_SYNC_NUMLOCK 0
#define TRACE_VNC_KEY_SYNC_NUMLOCK_ENABLED 0
#define TRACE_VNC_KEY_SYNC_NUMLOCK_BACKEND_DSTATE() (0)
static inline void trace_vnc_key_sync_numlock(bool on) {
    (void)on;
}
#define TRACE_VNC_MSG_CLIENT_AUDIO_DISABLE 0
#define TRACE_VNC_MSG_CLIENT_AUDIO_DISABLE_ENABLED 0
#define TRACE_VNC_MSG_CLIENT_AUDIO_DISABLE_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_client_audio_disable(void *state, void *ioc) {
    (void)state;
    (void)ioc;
}
#define TRACE_VNC_MSG_CLIENT_AUDIO_ENABLE 0
#define TRACE_VNC_MSG_CLIENT_AUDIO_ENABLE_ENABLED 0
#define TRACE_VNC_MSG_CLIENT_AUDIO_ENABLE_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_client_audio_enable(void *state, void *ioc) {
    (void)state;
    (void)ioc;
}
#define TRACE_VNC_MSG_CLIENT_AUDIO_FORMAT 0
#define TRACE_VNC_MSG_CLIENT_AUDIO_FORMAT_ENABLED 0
#define TRACE_VNC_MSG_CLIENT_AUDIO_FORMAT_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_client_audio_format(void *state, void *ioc, int fmt, int channels, int freq) {
    (void)state;
    (void)ioc;
    (void)fmt;
    (void)channels;
    (void)freq;
}
#define TRACE_VNC_MSG_CLIENT_CUT_TEXT 0
#define TRACE_VNC_MSG_CLIENT_CUT_TEXT_ENABLED 0
#define TRACE_VNC_MSG_CLIENT_CUT_TEXT_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_client_cut_text(void *state, void *ioc, int len) {
    (void)state;
    (void)ioc;
    (void)len;
}
#define TRACE_VNC_MSG_CLIENT_CUT_TEXT_EXT 0
#define TRACE_VNC_MSG_CLIENT_CUT_TEXT_EXT_ENABLED 0
#define TRACE_VNC_MSG_CLIENT_CUT_TEXT_EXT_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_client_cut_text_ext(void *state, void *ioc, int len, int flags) {
    (void)state;
    (void)ioc;
    (void)len;
    (void)flags;
}
#define TRACE_VNC_MSG_CLIENT_EXT_KEY_EVENT 0
#define TRACE_VNC_MSG_CLIENT_EXT_KEY_EVENT_ENABLED 0
#define TRACE_VNC_MSG_CLIENT_EXT_KEY_EVENT_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_client_ext_key_event(void *state, void *ioc, int down, int sym, int keycode) {
    (void)state;
    (void)ioc;
    (void)down;
    (void)sym;
    (void)keycode;
}
#define TRACE_VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST 0
#define TRACE_VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST_ENABLED 0
#define TRACE_VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_client_framebuffer_update_request(void *state, void *ioc, int incremental, int x, int y, int w, int h) {
    (void)state;
    (void)ioc;
    (void)incremental;
    (void)x;
    (void)y;
    (void)w;
    (void)h;
}
#define TRACE_VNC_MSG_CLIENT_KEY_EVENT 0
#define TRACE_VNC_MSG_CLIENT_KEY_EVENT_ENABLED 0
#define TRACE_VNC_MSG_CLIENT_KEY_EVENT_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_client_key_event(void *state, void *ioc, int down, int sym) {
    (void)state;
    (void)ioc;
    (void)down;
    (void)sym;
}
#define TRACE_VNC_MSG_CLIENT_POINTER_EVENT 0
#define TRACE_VNC_MSG_CLIENT_POINTER_EVENT_ENABLED 0
#define TRACE_VNC_MSG_CLIENT_POINTER_EVENT_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_client_pointer_event(void *state, void *ioc, int button_mask, int x, int y) {
    (void)state;
    (void)ioc;
    (void)button_mask;
    (void)x;
    (void)y;
}
#define TRACE_VNC_MSG_CLIENT_SET_DESKTOP_SIZE 0
#define TRACE_VNC_MSG_CLIENT_SET_DESKTOP_SIZE_ENABLED 0
#define TRACE_VNC_MSG_CLIENT_SET_DESKTOP_SIZE_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_client_set_desktop_size(void *state, void *ioc, int width, int height, int screens) {
    (void)state;
    (void)ioc;
    (void)width;
    (void)height;
    (void)screens;
}
#define TRACE_VNC_MSG_CLIENT_SET_ENCODINGS 0
#define TRACE_VNC_MSG_CLIENT_SET_ENCODINGS_ENABLED 0
#define TRACE_VNC_MSG_CLIENT_SET_ENCODINGS_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_client_set_encodings(void *state, void *ioc, int limit) {
    (void)state;
    (void)ioc;
    (void)limit;
}
#define TRACE_VNC_MSG_CLIENT_SET_PIXEL_FORMAT 0
#define TRACE_VNC_MSG_CLIENT_SET_PIXEL_FORMAT_ENABLED 0
#define TRACE_VNC_MSG_CLIENT_SET_PIXEL_FORMAT_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_client_set_pixel_format(void *state, void *ioc, int bpp, int big_endian, int true_color) {
    (void)state;
    (void)ioc;
    (void)bpp;
    (void)big_endian;
    (void)true_color;
}
#define TRACE_VNC_MSG_CLIENT_SET_PIXEL_FORMAT_RGB 0
#define TRACE_VNC_MSG_CLIENT_SET_PIXEL_FORMAT_RGB_ENABLED 0
#define TRACE_VNC_MSG_CLIENT_SET_PIXEL_FORMAT_RGB_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_client_set_pixel_format_rgb(void *state, void *ioc, int red_max, int green_max, int blue_max, int red_shift, int green_shift, int blue_shift) {
    (void)state;
    (void)ioc;
    (void)red_max;
    (void)green_max;
    (void)blue_max;
    (void)red_shift;
    (void)green_shift;
    (void)blue_shift;
}
#define TRACE_VNC_MSG_CLIENT_XVP 0
#define TRACE_VNC_MSG_CLIENT_XVP_ENABLED 0
#define TRACE_VNC_MSG_CLIENT_XVP_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_client_xvp(void *state, void *ioc, int version, int action) {
    (void)state;
    (void)ioc;
    (void)version;
    (void)action;
}
#define TRACE_VNC_MSG_SERVER_AUDIO_BEGIN 0
#define TRACE_VNC_MSG_SERVER_AUDIO_BEGIN_ENABLED 0
#define TRACE_VNC_MSG_SERVER_AUDIO_BEGIN_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_server_audio_begin(void *state, void *ioc) {
    (void)state;
    (void)ioc;
}
#define TRACE_VNC_MSG_SERVER_AUDIO_DATA 0
#define TRACE_VNC_MSG_SERVER_AUDIO_DATA_ENABLED 0
#define TRACE_VNC_MSG_SERVER_AUDIO_DATA_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_server_audio_data(void *state, void *ioc, const void *buf, size_t len) {
    (void)state;
    (void)ioc;
    (void)buf;
    (void)len;
}
#define TRACE_VNC_MSG_SERVER_AUDIO_END 0
#define TRACE_VNC_MSG_SERVER_AUDIO_END_ENABLED 0
#define TRACE_VNC_MSG_SERVER_AUDIO_END_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_server_audio_end(void *state, void *ioc) {
    (void)state;
    (void)ioc;
}
#define TRACE_VNC_MSG_SERVER_DESKTOP_RESIZE 0
#define TRACE_VNC_MSG_SERVER_DESKTOP_RESIZE_ENABLED 0
#define TRACE_VNC_MSG_SERVER_DESKTOP_RESIZE_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_server_desktop_resize(void *state, void *ioc, int width, int height) {
    (void)state;
    (void)ioc;
    (void)width;
    (void)height;
}
#define TRACE_VNC_MSG_SERVER_EXT_DESKTOP_RESIZE 0
#define TRACE_VNC_MSG_SERVER_EXT_DESKTOP_RESIZE_ENABLED 0
#define TRACE_VNC_MSG_SERVER_EXT_DESKTOP_RESIZE_BACKEND_DSTATE() (0)
static inline void trace_vnc_msg_server_ext_desktop_resize(void *state, void *ioc, int width, int height, int reason) {
    (void)state;
    (void)ioc;
    (void)width;
    (void)height;
    (void)reason;
}
#define TRACE_VNC_SERVER_DPY_PAGEFLIP 0
#define TRACE_VNC_SERVER_DPY_PAGEFLIP_ENABLED 0
#define TRACE_VNC_SERVER_DPY_PAGEFLIP_BACKEND_DSTATE() (0)
static inline void trace_vnc_server_dpy_pageflip(void *dpy, int w, int h, int fmt) {
    (void)dpy;
    (void)w;
    (void)h;
    (void)fmt;
}
#define TRACE_VNC_SERVER_DPY_RECREATE 0
#define TRACE_VNC_SERVER_DPY_RECREATE_ENABLED 0
#define TRACE_VNC_SERVER_DPY_RECREATE_BACKEND_DSTATE() (0)
static inline void trace_vnc_server_dpy_recreate(void *dpy, int w, int h, int fmt) {
    (void)dpy;
    (void)w;
    (void)h;
    (void)fmt;
}
#define TRACE_XKEYMAP_EXTENSION 0
#define TRACE_XKEYMAP_EXTENSION_ENABLED 0
#define TRACE_XKEYMAP_EXTENSION_BACKEND_DSTATE() (0)
static inline void trace_xkeymap_extension(const char *name) {
    (void)name;
}
#define TRACE_XKEYMAP_KEYCODES 0
#define TRACE_XKEYMAP_KEYCODES_ENABLED 0
#define TRACE_XKEYMAP_KEYCODES_BACKEND_DSTATE() (0)
static inline void trace_xkeymap_keycodes(const char *name) {
    (void)name;
}
#define TRACE_XKEYMAP_KEYMAP 0
#define TRACE_XKEYMAP_KEYMAP_ENABLED 0
#define TRACE_XKEYMAP_KEYMAP_BACKEND_DSTATE() (0)
static inline void trace_xkeymap_keymap(const char *name) {
    (void)name;
}
#define TRACE_XKEYMAP_VENDOR 0
#define TRACE_XKEYMAP_VENDOR_ENABLED 0
#define TRACE_XKEYMAP_VENDOR_BACKEND_DSTATE() (0)
static inline void trace_xkeymap_vendor(const char *name) {
    (void)name;
}

#endif